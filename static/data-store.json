[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.16.0","content-config-digest","2bebb6604190067f","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://andrianov.dev\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"always\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image/\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true,\"allowedDomains\":[]},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false,\"svgo\":false},\"legacy\":{\"collections\":false}}","posts",["Map",11,12,28,29],"full-stack-rust-watering-system",{"id":11,"data":13,"body":24,"filePath":25,"digest":26,"deferredRender":27},{"title":14,"description":15,"date":16,"tags":17},"Full Stack Rust: From GPIO Pins to Telegram Bots","How I built an over-engineered plant watering system using Rust on both a Raspberry Pi Pico microcontroller and a backend server with PostgreSQL and Telegram integration.",["Date","2025-12-29T00:00:00.000Z"],[18,19,20,21,22,23],"rust","embedded","embassy","raspberry-pi","iot","telegram","import { Image } from 'astro:assets';\nimport watering1 from '/public/blogpost/watering1.jpg';\nimport watering2 from '/public/blogpost/watering2.jpg';\nimport watering3 from '/public/blogpost/watering3.jpg';\nimport watering4 from '/public/blogpost/watering4.jpg';\n\n*Or: How I spent way too much time automating something I could do in 30 seconds with a watering can*\n\n---\n\n## What Even Is This\n\nI built a plant watering system. Microcontroller reads soil moisture, sends data to my server, I get Telegram messages when my plants are dying. I can water them remotely with a button.\n\nThe twist: Rust all the way down. Firmware on a $6 chip with no OS? Rust. Backend with PostgreSQL and Telegram bot? Also Rust.\n\nSpoiler: I shared almost zero code between them. That wasn't the point.\n\n\u003CImage src={watering1} alt=\"The watering system setup\" />\n\n---\n\n## The Setup\n\n**Raspberry Pi Pico 2 W** - 150MHz, 512KB RAM, no OS.\n\nConnected: BME280 (temp/humidity/pressure), soil moisture sensor, OLED display, water pump, and an ultrasonic sensor for water level that I never got working and probably never will.\n\n```\n                        ┌───────────────────────────────────────┐\n                        │           Pico 2 W (Rust)             │\n                        │  BME280 + Soil Sensor + OLED + Pump   │\n                        └─────────────────┬─────────────────────┘\n                                          │\n                    POST /sensor          │           GET /tasks\n               (temp, humidity, soil)     │        (pump commands)\n                          │               │               ▲\n                          ▼               │               │\n                        ┌─────────────────▼───────────────┴─┐\n                        │           VPS (Rust)              │\n                        │  Axum → PostgreSQL → Teloxide     │\n                        └─────────────────┬─────────────────┘\n                                          │\n                          LISTEN/NOTIFY   │   Alerts + Controls\n                                          ▼\n                                    ┌───────────┐\n                                    │ Telegram  │\n                                    │   Bot     │\n                                    └───────────┘\n                                          │\n                                          ▼\n                                       My Phone\n                                   \"Water the plant\"\n```\n\n---\n\n## \"How Hard Can It Be?\"\n\nFamous last words.\n\nThe Rust embedded ecosystem has **[Embassy](https://embassy.dev)** - an async runtime for microcontrollers. Write async/await on bare metal, multiple concurrent tasks on a single-core chip. The pitch was too good.\n\nThis thing is amazing. I'm always surprised how good the Rust community is at developer tools and libraries.\n\n\u003CImage src={watering2} alt=\"Hardware components\" />\n\nThe architecture is basically actors - independent tasks talking through channels:\n\n```rust\n// Capacity 1: only latest reading matters, old data gets dropped\nstatic SENSOR_CHANNEL: Channel\u003CCriticalSectionRawMutex, SensorData, 1> = Channel::new();\n\n// Capacity 4: buffer HTTP requests when network is slow\nstatic HTTP_CHANNEL: Channel\u003CCriticalSectionRawMutex, HttpRequest, 4> = Channel::new();\n\n// Capacity 1: only latest pump command matters\nstatic PUMP_CHANNEL: Channel\u003CCriticalSectionRawMutex, PumpCommand, 1> = Channel::new();\n```\n\nEach task does one thing:\n\n```rust\n#[embassy_executor::task]\nasync fn sensor_task(i2c_bus: &'static I2cBus) {\n    loop {\n        let data = read_sensors(i2c_bus).await;\n        SENSOR_CHANNEL.send(data).await;\n        Timer::after_secs(60).await;\n    }\n}\n```\n\nSensor task reads, display task renders, network task sends, pump task waters. They don't know about each other - just channels. If you've done actor systems or used Tokio channels, this is familiar. That's the point.\n\nFirst milestone: blink an LED. It worked.\n\n---\n\n## Reality Check\n\nThen I tried to initialize WiFi.\n\n```rust\nlet (net_device, mut control, runner) = cyw43::new(state, pwr, spi, fw).await;\n```\n\nThe code compiled. The device did nothing. No LED, no logs. Just silence.\n\n### Three Days in GitHub Issues\n\nI tried everything. Different Embassy versions. Secure boot configs. Staring at the code hoping it would fix itself.\n\nFinally, buried in a [GitHub issue](https://github.com/embassy-rs/embassy/issues/3612): the RP2350 runs at 150MHz, not 133MHz like the RP2040. This breaks PIO timing for SPI communication.\n\nThe fix was a magic number that took three days to find:\n\n```rust\n// This constant represents mass of time consumed debugging\nconst PICO2W_CLOCK_DIVIDER: FixedU32\u003CU8> = FixedU32::from_bits(0x0300);\n```\n\nThe other part was recently broken WiFi drivers, so I had to roll back and pin to working commits. It's hard to be a pioneer. But I'm not really one - those who write these drivers are the ones who rock.\n\n### The TLS Situation\n\nMy server is behind Cloudflare. No HTTPS, no connection. I used [reqwless](https://github.com/drogue-iot/reqwless) with `embedded-tls`.\n\n```rust\nlet mut tls_read_buffer = [0u8; 16640];\nlet mut tls_write_buffer = [0u8; 16640];\n```\n\n33KB just for TLS buffers. 6% of my total RAM for one HTTPS connection.\n\nIt worked. Barely, but it worked.\n\nYes, I know MQTT exists. Yes, I know a home server with a broker would skip TLS on microcontroller entirely. That's the plan for version 2: add more infrastructure to water a plant. The solution to overengineering is always more engineering.\n\n\u003CImage src={watering3} alt=\"System in action\" />\n\n---\n\n## The Backend (The Easy Part)\n\nAfter embedded suffering, Rust on a server felt like cheating. [Axum](https://github.com/tokio-rs/axum), [SQLx](https://github.com/launchbadge/sqlx), [Teloxide](https://github.com/teloxide/teloxide) - the whole thing came together in a weekend.\n\nThe interesting bits:\n\n**Real-time processing without polling** - PostgreSQL LISTEN/NOTIFY wakes up my code only when new data arrives:\n\n```rust\nlet mut listener = PgListener::connect_with(&pool).await?;\nlistener.listen(\"sensor_data\").await?;\n\nloop {\n    let notification = listener.recv().await?;\n    process_sensor_data(notification.payload()).await?;\n}\n```\n\n**Power outage detection** - sensor reports every 60 seconds, so silence means trouble. The Pico doesn't send a \"dying gasp\" - it just stops. A background task on the backend checks `last_reading` every two minutes:\n\n```rust\nlet elapsed = (now - last_reading).whole_seconds();\nif elapsed > 150 && !active_outage {\n    db.start_outage().await?;\n    alerter.broadcast(\"Power outage detected!\").await?;\n}\n```\n\n**Detecting *absence* is philosophically weird - you're looking for something that isn't there.** The system knows power is off because it knows when it isn't. [The missile guidance approach to plant care.](https://www.youtube.com/watch?v=bZe5J8SVCYQ)\n\n---\n\n## The Moment It All Connected\n\nFirst time I saw this in my database:\n\n```json\n{\"temperature\": 23.5, \"humidity\": 45.2, \"pressure\": 1013.25, \"soil_moisture\": 67}\n```\n\n...sent from a chip the size of my thumb, through WiFi, through Cloudflare, into PostgreSQL - I screenshot everything. Sent it to friends who definitely didn't care but pretended to.\n\nFirst Telegram notification while away from home:\n\n> Soil moisture is low (28%). Consider watering.\n\n\u003CImage src={watering4} alt=\"Telegram bot interface\" />\n\n---\n\n## What \"Full Stack Rust\" Actually Means\n\nI expected shared code between firmware and backend. Common types, validation logic.\n\nReality: almost zero shared code.\n\nBut Embassy and Tokio feel almost identical:\n\n| Embedded (Embassy) | Backend (Tokio) |\n|-------------------|-----------------|\n| `#[embassy_executor::task]` | `#[tokio::main]` |\n| `Timer::after_secs(30).await` | `sleep(Duration::from_secs(30)).await` |\n| `CHANNEL.send(data).await` | `tx.send(data).await` |\n| `spawner.spawn(task())` | `tokio::spawn(task())` |\n\nSame patterns. Same intuition. Different worlds. The cognitive load of switching is near zero. When I changed a struct on the backend and forgot the firmware, SQLx's compile-time checks caught it.\n\nThat's what \"full stack\" actually gave me - not shared code, but **shared mental model**.\n\n---\n\n## Hindsight\n\n**What Rust gave me:** Confidence. If it compiles, it probably works. Same tooling everywhere. Fearless concurrency on both ends.\n\n**What it cost:** Compile times. Ecosystem churn (Embassy moves faster than its docs). The embedded learning curve is real - `no_std` is a different world. But Embassy is magic, giving a dumb web developer like me the ability to write bare metal code. One of the best feelings I've ever had.\n\n**What I'd do differently:** Use MQTT. (No) Add OTA updates. (Maybe) Fix the ultrasonic sensor. (Or just admit I never will)\n\n---\n\n## Was It Worth It?\n\nMy plants now have better monitoring than most production systems I've worked on. Real-time data in PostgreSQL, alerting with quiet hours, power outage detection, remote control via Telegram.\n\nTotal cost: ~$20 in hardware, mass(time). The plants are alive. That's more than I can say for my previous attempts at gardening.\n\nAll because I wanted to water my plants from my phone without getting up.\n\nIs it overkill? Obviously.\n\nWould I do it again? Already planning version 2.\n\n*(For future employers reading this: Am I prone to overengineering? Obviously not. This is a perfectly reasonable amount of infrastructure for watering a plant.)*\n\n---\n\n*The code is on GitHub if you want to steal ideas or judge my life choices: [firmware](https://github.com/ihorandrianov/auto-watering) and [backend](https://github.com/ihorandrianov/my-website). Just don't blame me if your plants die anyway - I'm a software developer, not a botanist.*","src/content/posts/full-stack-rust-watering-system.mdx","ecfbad7daac1b562",true,"algebraic-effects",{"id":28,"data":30,"body":38,"filePath":39,"digest":40,"deferredRender":27},{"title":31,"description":32,"date":33,"tags":34},"Algebraic Effects","Interactive playground for exploring algebraic effects in JavaScript",["Date","2026-01-12T00:00:00.000Z"],[18,35,36,37],"javascript","wasm","effects","import KryhtaPlayground from '../../components/KryhtaPlayground.tsx';\n\n# Algebraic Effects\n\n[KryhtaJS](https://github.com/ihorandrianov/kryhtajs) is a tiny JavaScript engine with algebraic effects, written in Rust and compiled to WebAssembly. It extends JavaScript with:\n\n- **`perform Effect!(args)`** triggers an effect and captures the continuation\n- **`handle { } with { }`** catches effects and decides how to resume\n- **`resume(value)`** is a one-shot continuation that resumes execution\n- **First-class handlers** can be stored and reused\n\n## Try It\n\n\u003CKryhtaPlayground client:only=\"react\" />\n\n## Generator Pattern\n\nEffects can implement generators without special syntax. `Yield!` is just another effect:\n\n\u003CKryhtaPlayground client:only=\"react\" example=\"generator\" />\n\n## Mutable State\n\nState can be implemented as a pattern. The handler threads state through continuations:\n\n\u003CKryhtaPlayground client:only=\"react\" example=\"state\" />\n\n## Early Exit\n\nIf you don't call `resume`, the computation stops:\n\n\u003CKryhtaPlayground client:only=\"react\" example=\"exit\" />\n\n## First-Class Handlers\n\nHandlers are values. You can store them in variables and reuse them:\n\n\u003CKryhtaPlayground client:only=\"react\" example=\"handler\" />","src/content/posts/algebraic-effects.mdx","adcbbeef228a42bd"]